"use strict";

//------------------------------------------------------------------------------

Object.defineProperty(exports, "__esModule", { value: true });

//------------------------------------------------------------------------------

const childProcess = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const process = require("process");
const tmp = require("tmp");
const vscode = require("vscode");
const WinReg = require("winreg");

//==============================================================================
// Constants

    // --- VSCode Arduino Extension ---

const ARDUINO_CONFIG_FILE = path.join(".vscode", "arduino.json");

const ARDUINO_PATH = "arduino.path";                        // Location of arduino executable

    // --- new items ---

const ESP8266FS_DATAFILES = "esp8266fs.dataFiles";          // Location of SPIFFS files
const ESP8266FS_PREFERENCES = "esp8266fs.preferencesPath";  // Location of Arduino Custom Packages
const ESP8266FS_SPIFFS_IMAGE = "esp8266fs.spiffsImage";     // Packed SPIFFS file
const ESP8266_PYTHON = "esp8266fs.python";                  // Python Executable
const ESP8266_LOGLEVEL = "esp8266fs.logLevel";              // Level of spew generated by this extension

const ESP8266_MKSPIFFS_EXECUTABLE = "esp8266fs.mkspiffs.executable";  // MKSPIFFS Executable
const ESP8266_MKSPIFFS_DEBUG_LEVEL = "esp8266fs.mkspiffs.debugLevel"; // Value passed to MKSPIFFS Executable
const ESP8266_MKSPIFFS_ALL_FILES = "esp8266fs.mkspiffs.allFiles";     // Value passed to MKSPIFFS Executable

const ESP8266_ESPTOOL_EXECUTABLE = "esp8266fs.esptool.executable";  // ESPTOOL Executable
const ESP8266_ESPTOOL_VERBOSITY = "esp8266fs.esptool.verbosity";    // Value passed to ESPTOOL Executable

const ESP8266_ESPOTA_PY = "esp8266fs.espota.py";               // EspOTA Python script
const ESP8266_ESPOTA_ESP_PORT = "esp8266fs.espota.esp.port";   // IP Port for ESP8266
const ESP8266_ESPOTA_HOST_IP = "esp8266fs.espota.host.ip";     // IP Address for Host
const ESP8266_ESPOTA_HOST_PORT = "esp8266fs.espota.host.port"; // IP Port for Host
const ESP8266_ESPOTA_AUTH = "esp8266fs.espota.auth";           // Authentication password for espota.py
const ESP8266_ESPOTA_DEBUG = "esp8266fs.espota.debug";         // Enable debug output from espota.py

//==============================================================================
// Logging

const RESET    = "\u001b[0m";
const BOLD     = "\u001b[1m";

const RED      = "\u001b[31m";
const GREEN    = "\u001b[32m";
const YELLOW   = "\u001b[33m";
const BLUE     = "\u001b[34m";
const MAGENTA  = "\u001b[35m";
const CYAN     = "\u001b[36m";

const BOLD_RED = "\u001b[31;1m";

//------------------------------------------------------------------------------

let outputChannel = null;
let logLevel = "normal"; // "normal", "verbose", "silent", "debug"

function log(message, color) {
    if (logLevel === "silent")
        return;

    if (color)
        console.log(`${color}${message}${RESET}`);
    else
        console.log(message);

    outputChannel.appendLine(message.replace(/\x1b\[[\d|\;]{1,4}m/g, ""));
}

//------------------------------------------------------------------------------

function logAnnounce(message)  { log(message, GREEN); }
function logUrgent(message)    { log(message, BOLD_RED); }
function logImportant(message) { log(message, RED); }
function logCommand(message)   { log(message, YELLOW); }
function logSpiffs(message)    { log(`  [SPIFFS] ${message}`, BLUE); }

//------------------------------------------------------------------------------


function logVerbose(message) {

    if (logLevel === "verbose" || logLevel === "debug")
        log(message, MAGENTA);
}

//------------------------------------------------------------------------------

function logDebug(message) {

    if (logLevel === "debug")
        log(message, CYAN);
}

//==============================================================================
// Helper functions

function stringToInt(value) {
    return parseInt(value, value.match(/^0x/i) ? 16 : 10);
}

//------------------------------------------------------------------------------

function toHex(decimal, width = 4) {
    return ("00000" + (Number(decimal).toString(16))).slice(-width).toUpperCase()
}

//------------------------------------------------------------------------------

function makeOsPath(dir) {
    dir = dir.replace(/\\/g, "/");

    if (dir.indexOf(" ") != -1)
        dir = `"${dir}"`;

    return dir;
}

//==============================================================================
// Utility functions

function getVscodeConfigValue(key) {
    return vscode.workspace.getConfiguration().get(key);
}

//------------------------------------------------------------------------------

function getOS() { return os.platform(); }

//------------------------------------------------------------------------------

function program(name) {
    return (getOS() === "win32" && name.indexOf(".") == -1)
        ? (name + ".exe")
        : name;
}

//------------------------------------------------------------------------------

function runCommand(command, args) {
    logVerbose("Running: " + command + " " + args.join(" "));

    const spawn = childProcess.spawnSync(command, args, { encoding: "utf8" });

    if (spawn.error)
        throw spawn.error;

    spawn.stdout
        .toString()
        .replace(/\r\n/, "\n")
        .split("\n")
        .forEach(line => logCommand(line.trimRight()));

    spawn.stderr
        .toString()
        .replace(/\r\n/, "\n")
        .split("\n")
        .forEach(line => logUrgent(line.trimRight()));

    if (spawn.status)
        throw `${command} returned ${spawn.status}`;

    return spawn.stdout.toString();
}

//-------------------------------------------------------------------------------

function getTempPath() {
    const temp = tmp.dirSync();

    logDebug(`System tmp path: "${temp}"`);

    return temp;
}

//------------------------------------------------------------------------------

function dirExists(dir) {
    try {
        return fs.statSync(dir).isDirectory();
    }
    catch (e) {
        return false;
    }
}

//------------------------------------------------------------------------------

function getFolders(dir) {
    return fs.readdirSync(dir);
}

//------------------------------------------------------------------------------

function fileExists(file) {
    try {
        return fs.statSync(file).isFile();
    }
    catch (e) {
        return false;
    }
}

//------------------------------------------------------------------------------

function readFile(name) {
    return fs.readFileSync(name, "utf8");
}

//------------------------------------------------------------------------------

function readLines(name) {
    return readFile(name).split(/[\r\n|\r|\n]/);
}

//------------------------------------------------------------------------------

function JSONify(obj) {
    return JSON.stringify(obj, null, " ");
}

//------------------------------------------------------------------------------

function getRegistryValue(hive, key, name) {
    return new Promise((resolve, reject) => {
        try {
            const regKey = new WinReg({
                hive,
                key,
            });

            regKey.valueExists(name, (e, exists) => {
                if (e) {
                    reject(e);
                }

                if (exists) {
                    regKey.get(name, (err, result) => {
                        if (!err) {
                            resolve(result ? result.value : "");
                        } else {
                            reject(err);
                        }
                    });
                } else {
                    resolve("");
                }
            });
        } catch (error) {
            reject(error);
        }
    });
}

//==============================================================================
// ESP8266FS Specific code
//==============================================================================

const ARDUINO_X32_REG_KEY = "\\SOFTWARE\\Arduino";
const ARDUINO_X64_REG_KEY = "\\SOFTWARE\\WOW6432Node\\Arduino";

async function getArduinoInstallPath() {
    switch (getOS()) {
        case "win32": {
            let dir = await getRegistryValue(WinReg.HKLM,
                (process.arch === "x64" ||
                 process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432"))
                    ? ARDUINO_X64_REG_KEY
                    : ARDUINO_X32_REG_KEY,
                "Install_Dir");

            if (!dir)
                throw `Can't find Arduino Registry Key`;

            dir = path.resolve(dir);

            if (dirExists(dir)) {
                return dir;
            }
            try {
                const file = path.resolve((runCommand("where",  [ "arduino" ]))).trim();

                file = path.resolve(file);

                if (fileExists(file)) {
                    return path.dirname(file);
                }
            }
            catch (error) {
            }

            break;
        }

        case "darwin": {
            const dir = [
                    path.join(process.env.HOME, "Applications"),
                    "/Applications"
                ].find(d => dirExists(path.join(d, "Arduino.app")));

            if (dir)
                return dir;

            break;
        }

        case "linux": {
            try {
                const file = path.resolve(runCommand("readlink", [ "-f", "$(which arduino)" ])).trim();

                if (fileExists(file))
                    return path.dirname(file);
            }
            catch (ex) { // Ignore the errors.
            }

            break;
        }
    }

    throw "Can't find Arduino executable.";
}

//------------------------------------------------------------------------------

async function getArduinoPath() {
    let dir = getVscodeConfigValue(ARDUINO_PATH) || await getArduinoInstallPath();

    if (!dir)
        throw "Can't find Arduino path.";

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `Arduino path "${dir} " doesn't exist.`;

    logVerbose(`Arduino path: "${dir}"`);
    return dir;
}

//-------------------------------------------------------------------------------

const USER_SHELL_FOLDERS = "\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";

function getPreferencesPath() {
    let dir = getVscodeConfigValue(ESP8266FS_PREFERENCES);

    if (!dir) {
        switch (getOS()) {
            case "win32":
                dir = path.join(process.env.LOCALAPPDATA, "Arduino15");
                break;

            case "linux":
                dir = path.join(process.env.HOME, ".arduino15");
                break;

            case "darwin":
                dir = path.join(process.env.HOME, "Library/Arduino15");
                break;
        }
    }

    if (!dir)
        throw "Can't find preferences path.";

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `Preferences path "${dir}" doesn't exist.`;

    logVerbose(`Preferences Path: "${dir}"`);
    return dir;
}

//-------------------------------------------------------------------------------

function getDataFilesPath(arduinoJson) {
    let dir = getVscodeConfigValue(ESP8266FS_DATAFILES) || "./data";

    if (dir.startsWith("."))
        dir = path.join(vscode.workspace.rootPath, dir);

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `ESP8266 Data Files path "${dir}" not found.`;

    logVerbose(`ESP8266 Data Files path: "${dir}"`);

    return dir;
}

//-------------------------------------------------------------------------------

function getSpiffsImage() {
    let file = getVscodeConfigValue(ESP8266FS_SPIFFS_IMAGE)
        ||path.join(getTempPath(), "./spiffs.bin");

    if (file.startsWith("."))
        file = path.join(vscode.workspace.rootPath, file);

    file = path.resolve(file);

    logVerbose(`SPIFFS Image: "${file}"`);
    return file;
}

//-------------------------------------------------------------------------------

async function getArduinoPreferences(preferencesPath) {
    const preferences = {};

    const file = path.join(preferencesPath, "preferences.txt");
    logVerbose(`Reading preferences from "${file}"`);

    readLines(file)
        .forEach(line => {
            if (line.startsWith("#") || line.length == 0)
                return;

            const pair = line.split("=");

            logDebug(`  "${pair[0]}"="${pair[1]}"`);
            preferences[pair[0]] = pair[1];
        }
    );

    return preferences;
}

//-------------------------------------------------------------------------------

async function getArduinoJson() {
    var json = JSON.parse(readFile(path.join(vscode.workspace.rootPath, ARDUINO_CONFIG_FILE)));

        // Split the configuration settings into
    if (json.configuration) {
        json.configuration.split(",").forEach(config => {
            let param = config.split("=");

            json[param[0]] = param[1];
        });
    }

    logDebug(`arduinoJson:`);
    JSONify(json).split("\n").map(line => logDebug(line));

    return json;
}
//-------------------------------------------------------------------------------

function _getTarget(arduinJson, preferences) {
    if (!arduinJson.board) {
        const target =
            {
                package: preferences["target_package"],
                architecture: preferences["target_platform"],
                board: preferences["board"]
            };

        return target;
    }

    const values = arduinJson.board.split(":");

    const target =
        {
            package: values[0],
            architecture: values[1],
            board: values[2]
        };

    return target;
}

//------------------------------------------------------------------------------

function getTarget(arduinJson, preferences) {
    const target = _getTarget(arduinJson, preferences);

    if (target.package !== "esp8266" || target.architecture !== "esp8266")
        throw "Current Arduino package/architecture is not ESP8266.";

    logDebug(`target:`);
    JSONify(target).split("\n").map(line => logDebug(line));

    return target;
}

//------------------------------------------------------------------------------

function _getMemoryConfiguration(arduinoJson, preferences, target) {
    if (arduinoJson.FlashSize)
        return arduinoJson.FlashSize;

    const flashSize = preferences["custom_FlashSize"];

    if (flashSize) {
        const match = flashSize.match(/^${target.board}_(\S+)/);

        if (match)
            return match[1];
    }

    throw "Can't determine Flash Size.";
}

//------------------------------------------------------------------------------

function getMemoryConfiguration(arduinoJson, preferences, target) {
    const config = _getMemoryConfiguration(arduinoJson, preferences, target);

    logVerbose(`Memory Config: ${config}`);
    return config;
}

//------------------------------------------------------------------------------

function getEsp8266PackagePath(preferencesPath, target) {
    const dir = path.join(preferencesPath, "packages", target.package, "hardware", target.architecture);

    if (!dirExists(dir))
        throw "ESP8266 has not been installed with the Arduino Board Manager.";

    const folders = getFolders(dir);

    if (folders.length != 1)
        throw "There should only be one ESP8266 Package installed with the Arduino Board Manager.";

    logImportant(`Found ESP8266 version ${folders[0]}`);
    return path.join(dir, folders[0]);
}

//------------------------------------------------------------------------------

function getEsp8266spiffs(packagesPath, target, memoryConfig, arduinoJson) {
    const spiffs = {};

    readLines(path.join(packagesPath, "boards.txt"))
        .forEach(line => {
            const match = line.match(`${target.board}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)
                       || line.match(`${target.board}\\.menu\\.FlashSize\\.${memoryConfig}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)

            if (match)
                spiffs[match[1]] = match[2];
        }
    );

    if (!spiffs.spiffs_start)
        throw `Missing "spiffs_start" definition: target = ${target}, config = ${memoryConfig}.`;

    if (!spiffs.spiffs_end)
        throw `Missing "spiffs_end" definition: target = ${target}, config = ${memoryConfig}.`;

    if (arduinoJson.UploadSpeed)
        spiffs.speed = arduinoJson.UploadSpeed;

    if (arduinoJson.ResetMethod)
        spiffs.resetmethod = arduinoJson.ResetMethod;

    logDebug(`spiffs:`);
    JSONify(spiffs).split("\n").map(line => logDebug(line));

    return spiffs;
}

//------------------------------------------------------------------------------

function getToolPath(toolsPath, tool) {
    const dir = path.join(toolsPath, tool);

    if (!dirExists(dir))
        throw `Can't locate "${tool}" path`;

    const folders = getFolders(dir);

    if (folders.length != 1)
        throw `There should only be one ESP8266 "${tool}" tool installed with the Arduino Board Manager.`;

    const file = path.join(dir, folders[0], program(tool));

    if (!fileExists(file))
        throw `Can't locate ${file}.`;

    logVerbose(`${tool}: ${CYAN}${file}`);
    logImportant(`Found ${tool} version ${folders[0]}`);
    return file;
}

//------------------------------------------------------------------------------

function getToolsPath(preferencesPath, target) {
    const dir = path.resolve(path.join(preferencesPath, "packages", target.package, "tools"));

    if (!dirExists(dir))
        throw "Can't find ESP8266 tools path.";

    logVerbose(`Tools Path: "${dir}"`);
    return dir;
}

//------------------------------------------------------------------------------

function getEspotaPy(packagePath) {
    const file = path.join(packagePath, "tools", "espota.py");

    if (!fileExists(file))
        throw "Can't find espota.py.";

    logVerbose(`espota.py: ${CYAN}${file}`);
    return file;
}

//------------------------------------------------------------------------------

function getPort(arduinoJson, preferences) {
    let port = arduinoJson.port || preferences["serial.port"];

    logVerbose(`Output Port: ${port}`);
    return port;
}

//------------------------------------------------------------------------------

function isIP(port) {
    return port.match(/^(\d+)\.(\d+).(\d+).(\d+)(:\d+)?$/);
}

//==============================================================================
// MKSPIFFS

function makeMkspiffsArgs(args) {
    const allFiles = getVscodeConfigValue(ESP8266_MKSPIFFS_ALL_FILES);

    if (allFiles)
    args.unshift("--all-files", allFiles);

    const debug = getVscodeConfigValue(ESP8266_MKSPIFFS_DEBUG_LEVEL);

    if (debug)
        args.unshift("--debug", debug);

    return args;
}

//------------------------------------------------------------------------------

function packFiles(mkspiffs, dataPath, spiffs, imagePath) {
    const dataSize = stringToInt(spiffs.spiffs_end) - stringToInt(spiffs.spiffs_start);
    const dataSizeInK = dataSize >> 10;
    const spiPage = stringToInt(spiffs.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffs.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Creating Image... (${imagePath})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`data   : ${dataPath}`);
    logSpiffs(`size   : ${dataSizeInK}K`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--create", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(imagePath)
        ])
    );
}

//------------------------------------------------------------------------------

function unpackFiles(mkspiffs, dataPath, spiffs, imagePath) {
    const dataSize = stringToInt(spiffs.spiffs_end) - stringToInt(spiffs.spiffs_start);
    const dataSizeInK = dataSize >> 10;
    const spiPage = stringToInt(spiffs.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffs.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Unpacking Image... (${imagePath})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`data   : ${dataPath}`);
    logSpiffs(`size   : ${dataSizeInK}K`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--unpack", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(imagePath)
        ])
    );
}

//------------------------------------------------------------------------------

function listFiles(mkspiffs, spiffs, spiffsImage){
    const spiPage = stringToInt(spiffs.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffs.spiffs_blocksize || "4096");

    logImportant(`SPIFFS List Files... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--list",
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

//------------------------------------------------------------------------------

function visualizeFiles(mkspiffs, spiffs, spiffsImage) {
    const spiPage = stringToInt(spiffs.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffs.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Visualize Files... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--visualize",
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

//==============================================================================
// ESPTOOL

function makeEsptoolArgs(args) {
    const verbosity = getVscodeConfigValue(ESP8266_ESPTOOL_VERBOSITY);

    if (verbosity)
        args.unshift(`-${verbosity}`);

    return args;
}

//------------------------------------------------------------------------------

function upload(esptool, spiffs, serialPort, imagePath) {
    const uploadAddress = `0x` + toHex(stringToInt(spiffs.spiffs_start), 6);
    const uploadSpeed = stringToInt(spiffs.speed);
    const resetMethod = spiffs.resetmethod;

    logImportant(`SPIFFS Uploading Image... (${imagePath})`);
    logSpiffs(`program: ${esptool}`);
    logSpiffs(`address: ${uploadAddress}`);
    logSpiffs(`reset  : ${resetMethod}`);
    logSpiffs(`port   : ${serialPort}`);
    logSpiffs(`speed  : ${uploadSpeed}`);

    runCommand(
        makeOsPath(esptool),
        makeEsptoolArgs([
            "-ca", uploadAddress,        // Address in flash.
            "-cd", resetMethod,          // Board reset method: "none", "ck", "nodemcu", or "wifio".
            "-cp", serialPort,           // Serial Port (Default Linux: /dev/ttyUSB0, Windows: COM1, OSx: /dev/tty.usbserial).
            "-cb", uploadSpeed,          // Baud rate (Default: 115200).
            "-cf", makeOsPath(imagePath) // SPIFFS File
        ])
    );
}

//==============================================================================
// ESPOTA.PY

function uploadOTA(pythonCmd, espota, ip, imagePath) {
    logImportant(`SPIFFS Uploading Image... (${imagePath})`);
    logSpiffs(`  [SPIFFS] Python: ${pythonCmd}`);
    logSpiffs(`  [SPIFFS] EspOTA: ${espota}`);
    logSpiffs(`  [SPIFFS] IP    : ${ip}`);

    if (ip.indexOf(":") != -1) {
        ip.split(":");
    }

    let args = [
        makeOsPath(espota),               // Python code
        "--ip",     ip,                   // IP address
        "--spiffs",                       // Sending SPIFFS - do not FLASH!
        "--file",   makeOsPath(imagePath)
    ];

    if (getVscodeConfigValue())
        args.push("--debug");

    runCommand(makeOsPath(pythonCmd), args);
}

//==============================================================================
// SPIFFS Functions

function uploadSpiffs(dataPath, spiffs, spiffsImage, port, mkspiffs, espota, esptool) {
    log(`--- Packing SPIFFS file ---`);

    packFiles(mkspiffs, dataPath, spiffs, spiffsImage);

    log(`--- Uploading SPIFFS file ---`);

    if (isIP(port))
        uploadOTA(program("python"), espota, serialPort, imagePath);
    else
        upload(esptool, spiffs, port, spiffsImage);
}

//------------------------------------------------------------------------------

function unpackSpiffs(mkspiffs, dataPath, spiffs, spiffsImage) {
    log(`--- Unpacking SPIFFS file ---`);

    unpackFiles(mkspiffs, dataPath, spiffs, spiffsImage);
}

//------------------------------------------------------------------------------

function listSpiffs(mkspiffs, spiffs, spiffsImage) {
    log(`--- List SPIFFS file ---`);

    listFiles(mkspiffs, spiffs, spiffsImage);
}

//------------------------------------------------------------------------------

function visualizeSpiffs(mkspiffs, spiffs, spiffsImage) {
    log(`--- Visualize SPIFFS file ---`);
    
    visualizeFiles(mkspiffs, spiffs, spiffsImage);
}

//==============================================================================
// VSCode Command Handlers

async function _executeSpiffs(command) {
    const executable = await getArduinoPath();
    const preferencesPath = await getPreferencesPath();
    const preferences = await getArduinoPreferences(preferencesPath);
    const arduinoJson = await getArduinoJson();

    const target = getTarget(arduinoJson, preferences);

    const dataPath = getDataFilesPath(arduinoJson);
    const spiffsImage = getSpiffsImage();

    const memoryConfig = getMemoryConfiguration(arduinoJson, preferences, target);

    const esp8266packagePath = getEsp8266PackagePath(preferencesPath, target);

    const spiffs = getEsp8266spiffs(esp8266packagePath, target, memoryConfig, arduinoJson);

    const toolsPath = getToolsPath(preferencesPath, target);

    const port = getPort(arduinoJson, preferences);

    const mkspiffs = getToolPath(toolsPath, "mkspiffs");
    const esptool = getToolPath(toolsPath, "esptool");
    const espota = getEspotaPy(esp8266packagePath);

        // --- Ready to get down to business ---

    switch (command) {
        case "upload":
            uploadSpiffs(dataPath, spiffs, spiffsImage, port, mkspiffs, espota, esptool);
            break;

        case "unpack":
            unpackSpiffs(mkspiffs, dataPath, spiffs, spiffsImage);
            break;

        case "list":
            listSpiffs(mkspiffs, spiffs, spiffsImage);
            break;

        case "visualize":
            visualizeSpiffs(mkspiffs, spiffs, spiffsImage);
            break;
    }
}

//------------------------------------------------------------------------------

var locked = null;

async function executeSpiffs(command) {
    if (locked) {
        vscode.window.showErrorMessage(`ESP8266FS already running "${locked}"!`);
        return;
    }

    logLevel = getVscodeConfigValue(ESP8266_LOGLEVEL) || logLevel;

    logAnnounce(`ESP8266 SPIFFS interface started: "${command}".`);
    locked = command;

    try {
        await _executeSpiffs(command);
        vscode.window.showInformationMessage(`ESP266FS "${command}" completed!`);
    } catch (error) {
        logUrgent(error);
        vscode.window.showErrorMessage(error);
    }

    logAnnounce(`ESP8266 SPIFFS interface finished.`);
    locked = null;
}

//------------------------------------------------------------------------------

async function activate(context) {
    outputChannel = vscode.window.createOutputChannel("ESP8266FS");
    logLevel = getVscodeConfigValue(ESP8266_LOGLEVEL) || "normal";
    logVerbose(`ESP8266FS is now active!`);

    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.uploadSpiffs',    () => { executeSpiffs("upload"); }));
    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.unpackSpiffs',    () => { executeSpiffs("unpack"); }));
    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.listSpiffs',      () => { executeSpiffs("list"); }));
    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.visualizeSpiffs', () => { executeSpiffs("visualize"); }));
}

exports.activate = activate;

//------------------------------------------------------------------------------

function deactivate() {}

exports.deactivate = (() => {});